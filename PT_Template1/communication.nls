;;; File to be included in NetLogo Mutliagent Models
;;; Communication for NetLogo Multiagent models
;;; Includes primitives for message creation and handling in NetLogo 
;;; Original Version for Netlogo 2 (2005) I. Sakellariou
;;; Adapted to NetLogo 4 (2008) I. Sakellariou
;;; Edited by: Oscar, Ã–mer, Adam
;;; Requirements
;;; 1) All agents that are able to communicate MUST have a declated -own variable incoming-queue.
;;; This is the variable to which all messages are recorded. So, in your model if there is a breed of turtles 
;;; which you desire to communicate, then you should have a BREED-own [incoming-queue] declaration (along with any other 
;;; variables that you wish to include in your model.
;;; MAKE SURE that when you create the variables you set its values to empty list ([]).
;;; 2) Your model should have a switch (check NetLogo manual) named "show_messages" 



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;; COMMUNICATION
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; MESSAGE PROCESSING ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Sending Messages
;; (One man's send is another man's receive..)
;; The second commented out line presents an alternative send implementation. 
;; The commented out line represents an alternative method. 
;; Problem: What if the agent I am sending the message is "killed" 
;; Solution: Nothing Happens. Could yield an error message Alternative: create a safe send.
;; Define a new performative for help requests
globals [help_performative]


to send [msg]
  let recipients get-receivers msg
  let recv 0
  foreach recipients [i ->
   set recv turtle (read-from-string i)
   if recv != nobody [without-interruption [ask recv [receive msg]]] ;; read-from-string is required to convert the string to number
  ]
end

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Message reception deals with updating incoming-queue
to receive [msg]


  if show_messages [show msg]
  set incoming-queue lput msg incoming-queue
  
  ; Process the message to identify the requesting cop and the receiving cops
  let requesting-cop extract-requesting-cop msg
  let receiving-cops extract-receiving-cops msg
  
  ; Print information about the requesting cop and the receiving cops
  print (word "Requesting Cop: " requesting-cop)
  print (word "Receiving Cops: " receiving-cops)
  
  ; Check if the message contains information about a terrorist
  let content get-content msg
  if member? "terrorist" content [
    ; Extract location from the message
    let location extract-location content
    ; Move the receiving cop to the specified location
    move-to-location location
  ]
end


to-report extract-location [content]
  ; Extract the location from the content
  let parts remove "Location" (word content)
  let location (word item 0 parts "-" item 1 parts) 
  report location
end
; Move to the location in the message
to move-to-location [location]
  let xcorT item 0 location
  let ycorT item 1 location
  move-to patch xcorT ycorT
end

to-report extract-requesting-cop [msg]
  ; Extract the sender ID from the message
  let sender get-sender msg
  ; Extract the requesting cop ID from the sender information
  let requesting-cop remove "Cop " sender
  report requesting-cop
end

to-report extract-receiving-cops [msg]
  ; Extract the receivers from the message
  let receivers get-receivers msg
  ; Filter out the requesting cop from the receivers
  let receiving-cops remove (word "Cop " who) receivers
  report receiving-cops
end


;; This reporter returns the next message in the list and removes it from the queue.
to-report get-message
  if empty? incoming-queue [report "no_message"]
  let nextmsg first incoming-queue
  remove-msg
  report nextmsg     
end 

;; This reporter returns the next message in the list WITHOUT removimg it from the queue.
to-report get-message-no-remove
  if empty? incoming-queue [report "no_message"]
  report first incoming-queue
end

;; Explicit remove-msg. 
;; This is needed since reporters *cannot* change a variable's values (apparently). 
to remove-msg
  set incoming-queue but-first incoming-queue
end 

;; broadcasting to all agents of breed t-breed
to broadcast-to [t-breed msg agent]
  foreach [who] of t-breed [i ->
    ifelse i = agent [
      ;;;do nothing
      ][
       send add-receiver i msg 
      ]        
  ]
end 


;; Creating Messages and adding the sender.
to-report create-message [performative]
 report (list performative (word "sender:" who) ) 
end 

to-report create-reply [performative msg]
let msgOut 0
    
 set msgOut create-message performative
 set msgOut add-receiver (get-sender msg) msgOut
 report msgOut
end 


;; Accesing information on Messages
;; Reports the sender of a message
to-report get-sender [msg] 
  report remove "sender:" first (filter [i -> not is-number? i and member? "sender:" i] msg) 
  ;;report item ((position "sender:" msg) + 1) msg 
end

;; Reports (returns) the content of a message
to-report get-content [msg]
  let content-position position "content:" msg
  ifelse is-number? content-position [
    ; Extract the content if "content:" exists in the message
    report item (content-position + 1) msg
  ] [
    ; Return an empty string if "content:" doesn't exist in the message
    report ""
  ]
end


;; Reports the list of receivers of a message
to-report get-receivers [msg]
  report map [i -> remove "receiver:" i] filter [i -> not is-number? i and member? "receiver:" i] msg
end 

;; reports the message performative. 
to-report get-performative [msg]
  report first msg
end 

;;; ADDING FIELDS TO A MESSAGE
;; Adding a sender to a message.
to-report add-sender [sender msg]
  report add msg "sender:" sender
end

;; add a receiver
to-report add-receiver [receiver msg]
  report add msg "receiver:" receiver
end

;; adding multiple recipients
to-report add-multiple-receivers [receivers msg]
  foreach receivers
  [
    i -> set msg add-receiver i msg
  ]
  report msg
end

;; Adding content to a message 
to-report add-content [content msg]
  report add msg "content:" content
end

;; Primitive Add command 
to-report add [msg field value]
  ifelse field = "content:"
  [report lput value lput field msg]
  [report lput (word field value) msg]
end  

